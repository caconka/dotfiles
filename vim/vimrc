" Stop acting like classic vi
set history=1000

" Persist undo history between file editing sessions.
set undodir=~/.vim/undo//
set undofile
set noswapfile
set nobackup

" Settings about files
set encoding=utf-8
scriptencoding utf-8
filetype indent plugin on
set backspace=indent,eol,start
set hidden
set autoindent
set mouse=a

" Scrolling when we're n lines away from margins
set scrolloff=8
set sidescrolloff=15
set sidescroll=1

" Tags
set tags+=tags;$HOME

" Colorscheme configuration.
if (has("termguicolors"))
	set termguicolors
endif

if &t_Co > 2
	syntax on

	silent! colorscheme onehalflight
	autocmd colorscheme onehalflight highlight Italic cterm=italic gui=italic

	set background=light

	highlight Folded cterm=reverse ctermbg=0 ctermfg=8
	highlight VertSplit cterm=NONE ctermbg=NONE ctermfg=8
	highlight Conceal cterm=NONE ctermbg=NONE ctermfg=8

	highlight DiffAdd ctermfg=green cterm=bold
	highlight DiffDelete ctermfg=red cterm=bold
	highlight DiffChange ctermfg=yellow

	highlight Pmenu ctermbg=8 ctermfg=0
	highlight Pmenusel ctermbg=15 ctermfg=0

	set colorcolumn=120

	highlight ExtraWhitespace ctermbg=1
	match ExtraWhitespace /\s\+$/
else
	set list
	set listchars=tab:\│\ ,trail:·,eol:¬,extends:>,precedes:<
endif

set fillchars+=vert:\┊
set noshowmode
set laststatus=1       " always show statusbar
set wildmenu           " enable visual wildmenu
set wildoptions=pum

set nowrap          " don't wrap long lines
set number          " show line numbers
set relativenumber  " show numbers as relative by default
set showmatch       " higlight matching parentheses and brackets
set autoread        " if file is changed on disk
set ignorecase      " searching is not case sensitive
set hlsearch        " Highlighting when search

" Italics
let &t_ZH="\e[3m"
let &t_ZR="\e[23m"
highlight Comment cterm=italic

"" Change tab tittle
autocmd BufEnter * let &titlestring = "%:t"
set title

" tmux screen view
if &term == "screen"
	set t_Co=256
endif

let mapleader="\<Space>"

" Buffers
map <C-l> :bnext<CR>
map <C-h> :bprev<CR>
map <leader>d :bd<CR>
map <leader>ad :%bd<CR>

" Tabs
vmap <Tab> >gv
vmap <S-Tab> <gv

" Move lines vertically
nnoremap <C-j> :m .+1<CR>==
nnoremap <C-k> :m .-2<CR>==
vnoremap <C-j> :m '>+1<CR>gv=gv
vnoremap <C-k> :m '<-2<CR>gv=gv

" Tabs
set tabstop=2
set softtabstop=0 noexpandtab
set shiftwidth=2

" Toggle conceallevel
nnoremap <leader>c :let &cole=(&cole == 2) ? 0 : 2 <bar> echo 'conceallevel ' . &cole <CR>

" Paste clipboard
let os=substitute(system('uname'), '\n', '', '')
if os == 'Linux'
	nnoremap <C-R>+ :r !xclip -selection clipboard -o<CR>
else
	nnoremap <C-R>+ :r !pbpaste<CR>
	noremap! <C-?> <C-h>
endif

" fzf needs to be configured before loads the plugin fzf.vim
set rtp+=~/.fzf

" ###################
" # Custom commands #
" ###################
function! s:tabToggle()
	if &expandtab
		set shiftwidth=4
		set softtabstop=0
		set noexpandtab
	else
		set shiftwidth=4
		set softtabstop=4
		set expandtab
	endif
endfunction
command! TabToggle :call s:tabToggle()

function! s:wrapToggle()
	if &wrap
		echo "Wrap OFF"
		set nowrap
		nnoremap j j
		nnoremap k k
		nnoremap 0 0
		nnoremap $ $
	else
		echo "Wrap ON"
		set wrap
		set showbreak=↪\  linebreak breakindent
		nnoremap j gj
		nnoremap k gk
		nnoremap 0 g0
		nnoremap $ g$
		onoremap <silent> j gj
		onoremap <silent> k gk
	endif
endfunction
command! WrapToggle :call s:wrapToggle()

" Beautify JSON
function! s:jsonFmt()
	%!python -m json.tool
	%s;^\(\s\+\);\=repeat(' ', len(submatch(0))/2);g
endfunction
command! JsonFmt :call s:jsonFmt()

" Light theme
function! s:lightMode()
	set background=light
	colorscheme onehalflight
	AirlineTheme onehalflight
	let g:fzf_colors={}
endfunction
command! LightMode :call s:lightMode()

" Dark theme
function! s:darkMode()
	set background=dark
	colorscheme nord
	AirlineTheme nord
	let g:fzf_colors = { "bg+": ["bg", "CursorLine", "CursorColumn"] }
endfunction
command! DarkMode :call s:darkMode()

" Git add current buffer
function! s:gitAddBuffer()
	w
	windo !git add %
endfunction
command! GitAddBuffer :call s:gitAddBuffer()

" Git blame
function! s:gitBlame()
	windo !git blame %
endfunction
command! Blame :call s:gitBlame()

" :E to create a new file inside new folder(s)
function s:mkdir(...)
	if !a:0
				\|| isdirectory(a:1)
				\|| filereadable(a:1)
				\|| isdirectory(fnamemodify(a:1, ':p:h'))
		return
	endif
	return mkdir(fnamemodify(a:1, ':p:h'), 'p')
endfunction
command -bang -bar -nargs=? -complete=file E :call s:mkdir(<f-args>) | e<bang> <args>

function! s:editFile(file)
	if a:file ==# 'todo'
		e ~/notes/todo.md
	elseif a:file ==# 'note'
		e ~/notes/note.md
	endif
endfunction
" Edit todo list
command! Todo :call s:editFile('todo')
" Edit notes
command! Note :call s:editFile('note')
